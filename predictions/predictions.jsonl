{"instance_id": "django__django-10426", "model_name_or_path": "claude-3-7-sonnet-20250219", "model_patch": "diff --git a/django/core/management/commands/showmigrations.py b/django/core/management/commands/showmigrations.py\nindex 9c9c9c9c9c..1111111111 100644\n--- a/django/core/management/commands/showmigrations.py\n+++ b/django/core/management/commands/showmigrations.py\n@@ -1,5 +1,6 @@\n from django.apps import apps\n from django.core.management.base import BaseCommand, CommandError\n+from django.db.migrations.loader import MigrationLoader\n \n \n class Command(BaseCommand):\n@@ -42,6 +43,10 @@ class Command(BaseCommand):\n         # Load migrations\n         connection = connections[options['database']]\n         loader = MigrationLoader(connection, ignore_no_migrations=True)\n+        \n+        # Check for nonexistent app_labels\n+        app_labels = set(app_labels or [])\n+        invalid_apps = app_labels - set(loader.migrated_apps)\n+        if invalid_apps:\n+            raise CommandError(\"App '%s' does not have migrations.\" % list(invalid_apps)[0])\n \n         # If no app_labels are specified, show all\n         if not app_labels:"}
{"instance_id": "django__django-12700", "model_name_or_path": "claude-3-7-sonnet-20250219", "model_patch": "diff --git a/django/views/debug.py b/django/views/debug.py\nindex 9c9c9c9c9..1a1a1a1a1 100644\n--- a/django/views/debug.py\n+++ b/django/views/debug.py\n@@ -84,6 +84,18 @@ def cleanse_setting(key, value):\n     \"\"\"\n     if key.startswith(('SECRET', 'PASSWORD', 'API', 'TOKEN',)):\n         return CLEANSED_SUBSTITUTE\n+    # If the value is a list or tuple, recursively cleanse the items\n+    if isinstance(value, (list, tuple)):\n+        clean_value = []\n+        for item in value:\n+            clean_value.append(cleanse_setting('', item))\n+        if isinstance(value, tuple):\n+            return tuple(clean_value)\n+        return clean_value\n+    # If the value is a dict, recursively cleanse the items\n     if isinstance(value, dict):\n         clean_value = {}\n         for subkey, subvalue in value.items():\n@@ -91,6 +103,7 @@ def cleanse_setting(key, value):\n             if subkey.startswith(('SECRET', 'PASSWORD', 'API', 'TOKEN',)):\n                 clean_value[subkey] = CLEANSED_SUBSTITUTE\n             else:\n+                # Recursively cleanse the subvalue\n                 clean_value[subkey] = cleanse_setting(subkey, subvalue)\n         return clean_value\n     return value"}
{"instance_id": "django__django-13212", "model_name_or_path": "claude-3-7-sonnet-20250219", "model_patch": "diff --git a/django/core/validators.py b/django/core/validators.py\nindex 9c1c9c9c9a..a9c9c9c9a9 100644\n--- a/django/core/validators.py\n+++ b/django/core/validators.py\n@@ -47,7 +47,7 @@ class RegexValidator:\n         if not self.regex.search(value):\n             raise ValidationError(\n                 self.message,\n-                code=self.code,\n+                code=self.code, params={'value': value},\n             )\n \n \n@@ -77,7 +77,7 @@ class EmailValidator:\n         if not value or '@' not in value:\n             raise ValidationError(self.message, code=self.code)\n         user_part, domain_part = value.rsplit('@', 1)\n-\n+        \n         if not self.user_regex.match(user_part):\n             raise ValidationError(self.message, code=self.code)\n \n@@ -87,7 +87,7 @@ class EmailValidator:\n             # Try for possible IDN domain-part\n             try:\n                 domain_part = punycode(domain_part)\n-            except UnicodeError:\n+            except UnicodeError:  \n                 pass\n             else:\n                 if self.domain_regex.match(domain_part):\n@@ -95,7 +95,7 @@ class EmailValidator:\n         raise ValidationError(\n             self.message,\n             code=self.code,\n-        )\n+            params={'value': value})\n \n \n validate_email = EmailValidator()\n@@ -107,7 +107,7 @@ class URLValidator(RegexValidator):\n     def __call__(self, value):\n         # Check if the scheme is valid.\n         scheme = value.split(':', 1)[0].lower()\n-        if scheme not in self.schemes:\n+        if scheme not in self.schemes:  \n             raise ValidationError(self.message, code=self.code)\n \n         # Then check full URL\n@@ -115,7 +115,7 @@ class URLValidator(RegexValidator):\n             super().__call__(value)\n         except ValidationError as e:\n             # Trivial case failed. Try for possible IDN domain\n-            if value:\n+            if value:  \n                 try:\n                     scheme, rest = value.split(':', 1)\n                 except ValueError:\n@@ -130,7 +130,7 @@ class URLValidator(RegexValidator):\n                     super().__call__('%s:%s' % (scheme, rest))\n                 except ValidationError:\n                     raise ValidationError(\n-                        self.message,\n+                        self.message, params={'value': value},\n                         code=self.code,\n                     )\n                 else:\n@@ -147,7 +147,7 @@ class BaseValidator:\n         if cleaned is None:\n             cleaned = self.clean(value)\n         if self.compare(cleaned, self.limit_value):\n-            raise ValidationError(self.message, code=self.code)\n+            raise ValidationError(self.message, code=self.code, params={'value': value})\n \n     def __eq__(self, other):\n         return (\n@@ -193,7 +193,7 @@ class DecimalValidator:\n         if not self.decimal_places_re.match(digits):\n             raise ValidationError(\n                 self.messages['decimal_places'],\n-                code='decimal_places',\n+                code='decimal_places', params={'value': value},\n                 params={'decimal_places': self.decimal_places},\n             )\n         if not self.max_digits_re.match(digits):\n@@ -201,7 +201,7 @@ class DecimalValidator:\n                 self.messages['max_digits'],\n                 code='max_digits',\n                 params={'max_digits': self.max_digits},\n-            )\n+                )\n \n     def __eq__(self, other):\n         return (\n@@ -219,7 +219,7 @@ class FileExtensionValidator:\n         ext = os.path.splitext(value.name)[1][1:].lower()\n         if self.allowed_extensions and ext not in self.allowed_extensions:\n             raise ValidationError(\n-                self.message,\n+                self.message, params={'value': value.name},\n                 code=self.code,\n                 params={'extension': ext, 'allowed_extensions': ', '.join(self.allowed_extensions)}\n             )\n@@ -235,7 +235,7 @@ class ProhibitNullCharactersValidator:\n     def __call__(self, value):\n         if '\\x00' in str(value):\n             raise ValidationError(\n-                self.message,\n+                self.message, params={'value': value},\n                 code=self.code,\n             )\n \n@@ -252,7 +252,7 @@ class StepValueValidator:\n         if not isinstance(value, (int, float, Decimal)):\n             raise ValidationError(\n                 self.message,\n-                code=self.code,\n+                code=self.code, params={'value': value},\n                 params={'step_value': self.step_value},\n             )\n         mod = Decimal(str(value)) % Decimal(str(self.step_value))\n@@ -260,7 +260,7 @@ class StepValueValidator:\n         if mod != 0 and abs(mod - self.step_value) > self.precision:\n             raise ValidationError(\n                 self.message,\n-                code=self.code,\n+                code=self.code, params={'value': value},\n                 params={'step_value': self.step_value},\n             )"}
{"instance_id": "django__django-13413", "model_name_or_path": "claude-3-7-sonnet-20250219", "model_patch": "diff --git a/django/contrib/admin/filters.py b/django/contrib/admin/filters.py\nindex 9c9c9c9c9c..1c1c1c1c1c 100644\n--- a/django/contrib/admin/filters.py\n+++ b/django/contrib/admin/filters.py\n@@ -177,6 +177,14 @@ class BooleanFieldListFilter(FieldListFilter):\n         self.lookup_kwarg_isnull = '%s__isnull' % field.name\n         self.lookup_val = params.get(self.lookup_kwarg)\n         self.lookup_val_isnull = params.get(self.lookup_kwarg_isnull)\n+        self.lookup_choices = field.get_choices(include_blank=False)\n+        self.true_val = _('Yes')\n+        self.false_val = _('No')\n+        \n+        # If field has choices, use the display value for True and False\n+        if self.lookup_choices:\n+            for value, display in self.lookup_choices:\n+                if value is True or value is False:\n+                    setattr(self, '%s_val' % str(value).lower(), display)\n \n     def expected_parameters(self):\n         return [self.lookup_kwarg, self.lookup_kwarg_isnull]\n@@ -193,7 +201,7 @@ class BooleanFieldListFilter(FieldListFilter):\n             yield {\n                 'selected': self.lookup_val == '1',\n                 'query_string': cl.get_query_string({self.lookup_kwarg: '1'}, [self.lookup_kwarg_isnull]),\n-                'display': _('Yes'),\n+                'display': self.true_val,\n             }\n         if self.lookup_val_isnull != 'True':\n             yield {\n@@ -205,7 +213,7 @@ class BooleanFieldListFilter(FieldListFilter):\n             yield {\n                 'selected': self.lookup_val == '0',\n                 'query_string': cl.get_query_string({self.lookup_kwarg: '0'}, [self.lookup_kwarg_isnull]),\n-                'display': _('No'),\n+                'display': self.false_val,\n             }\n \n FieldListFilter.register(lambda f: isinstance(f, models.BooleanField), BooleanFieldListFilter)"}
{"instance_id": "django__django-14238", "model_name_or_path": "claude-3-7-sonnet-20250219", "model_patch": "--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1022,7 +1022,7 @@ class AutoFieldMeta(type):\n     \"\"\"Metaclass to maintain backward inheritance compatibility.\"\"\"\n \n     def __new__(cls, name, bases, namespace, **kwargs):\n-        if name != \"AutoField\" and bases[0].__name__ != \"AutoField\":\n+        if name not in {\"AutoField\", \"BigAutoField\", \"SmallAutoField\"} and not any(base.__name__ in {\"AutoField\", \"BigAutoField\", \"SmallAutoField\"} for base in bases):\n             namespace[\"_subclasses\"] = {}\n         return super().__new__(cls, name, bases, namespace, **kwargs)"}
{"instance_id": "django__django-16902", "model_name_or_path": "claude-3-7-sonnet-20250219", "model_patch": "diff --git a/django/db/backends/oracle/functions.py b/django/db/backends/oracle/functions.py\nindex 9c9c9c9c9c..9c9c9c9c9c 100644\n--- a/django/db/backends/oracle/functions.py\n+++ b/django/db/backends/oracle/functions.py\n@@ -1,5 +1,5 @@\n from django.db.models.functions import (\n-    Chr, ConcatPair, Greatest, Least, Length, LPad, Repeat, RPad, Substr,\n+    Chr, Coalesce, ConcatPair, Greatest, Least, Length, LPad, Repeat, RPad, Substr,\n )\n \n \n@@ -33,7 +33,7 @@ class OracleSubstr(Substr):\n \n \n def Right(self, compiler, connection, **extra_context):\n-    return self.as_sql(\n+    sql, params = self.as_sql(\n         compiler, connection,\n         function='SUBSTR',\n         template=\"%(function)s(%(expressions)s, -%(length)s, %(length)s)\",\n@@ -41,6 +41,7 @@ def Right(self, compiler, connection, **extra_context):\n             'length': self.get_source_expressions()[1],\n         },\n     )\n+    return \"CASE WHEN %(length)s = 0 THEN '' ELSE %(sql)s END\" % {'length': params[1], 'sql': sql}, params\n \n \n def StrIndex(self, compiler, connection, **extra_context):\ndiff --git a/django/db/backends/sqlite3/functions.py b/django/db/backends/sqlite3/functions.py\nindex 9c9c9c9c9c..9c9c9c9c9c 100644\n--- a/django/db/backends/sqlite3/functions.py\n+++ b/django/db/backends/sqlite3/functions.py\n@@ -1,5 +1,5 @@\n from django.db.models.functions import (\n-    Extract, Greatest, Least, Length, LPad, RPad, Substr,\n+    Coalesce, Extract, Greatest, Least, Length, LPad, RPad, Substr,\n )\n \n \n@@ -33,7 +33,7 @@ def RPad(self, compiler, connection, **extra_context):\n \n \n def Right(self, compiler, connection, **extra_context):\n-    return self.as_sql(\n+    sql, params = self.as_sql(\n         compiler, connection,\n         function='SUBSTR',\n         template=\"%(function)s(%(expressions)s, -%(length)s, %(length)s)\",\n@@ -41,6 +41,7 @@ def Right(self, compiler, connection, **extra_context):\n             'length': self.get_source_expressions()[1],\n         },\n     )\n+    return \"CASE WHEN %(length)s = 0 THEN '' ELSE %(sql)s END\" % {'length': params[1], 'sql': sql}, params\n \n \n def Substr(self, compiler, connection, **extra_context):"}
{"instance_id": "matplotlib__matplotlib-23049", "model_name_or_path": "claude-3-7-sonnet-20250219", "model_patch": "diff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex 3c3c4c0a5..a0b6c9e6c 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -2214,7 +2214,7 @@ def xticks(ticks=None, labels=None, **kwargs):\n     return gca().set_xticks(ticks, labels, **kwargs)\n \n \n-def yticks(ticks=None, labels=None, **kwargs):\n+def yticks(ticks=None, labels=None, *, minor=False, **kwargs):\n     \"\"\"\n     Get or set the current tick locations and labels of the y-axis.\n \n@@ -2226,6 +2226,8 @@ def yticks(ticks=None, labels=None, **kwargs):\n         List of label text. Defaults to list of the form ``['$0$', '$1$', ...]``\n         or ``['$0$', '$2$', ...]`` if the number of ticks exceeds 10.\n         Labels are currently rotation-invariant.\n+    minor : bool, default: False\n+        If True, set minor ticks instead of major ticks.\n     **kwargs\n         `.Text` properties for the labels.\n \n@@ -2240,7 +2242,7 @@ def yticks(ticks=None, labels=None, **kwargs):\n     >>> locs, labels = plt.yticks()  # Get the current locations and labels\n     >>> plt.yticks(np.arange(0, 1, step=0.2))  # Set label locations\n     >>> plt.yticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels\n-    >>> plt.yticks([0, 1, 2], ['January', 'February', 'March'],\n+    >>> plt.yticks([0, 1, 2], ['January', 'February', 'March'], minor=False,\n     ...            rotation=45)  # Set text labels and properties\n     >>> plt.yticks([])  # Disable yticks\n     \"\"\"\n@@ -2248,7 +2250,7 @@ def yticks(ticks=None, labels=None, **kwargs):\n     ax = gca()\n     if ticks is None and labels is None:\n         locs = ax.get_yticks()\n-        labels = ax.get_yticklabels()\n+        labels = ax.get_yticklabels(minor=minor)\n         return locs, labels\n     return ax.set_yticks(ticks, labels, **kwargs)\n \ndiff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex a0b6c9e6c..c9b1e1c9c 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -2196,7 +2196,7 @@ def xscale(value, **kwargs):\n     return gca().set_xscale(value, **kwargs)\n \n \n-def xticks(ticks=None, labels=None, **kwargs):\n+def xticks(ticks=None, labels=None, *, minor=False, **kwargs):\n     \"\"\"\n     Get or set the current tick locations and labels of the x-axis.\n \n@@ -2208,6 +2208,8 @@ def xticks(ticks=None, labels=None, **kwargs):\n         List of label text. Defaults to list of the form ``['$0$', '$1$', ...]``\n         or ``['$0$', '$2$', ...]`` if the number of ticks exceeds 10.\n         Labels are currently rotation-invariant.\n+    minor : bool, default: False\n+        If True, set minor ticks instead of major ticks.\n     **kwargs\n         `.Text` properties for the labels.\n \n@@ -2222,7 +2224,7 @@ def xticks(ticks=None, labels=None, **kwargs):\n     >>> locs, labels = plt.xticks()  # Get the current locations and labels\n     >>> plt.xticks(np.arange(0, 1, step=0.2))  # Set label locations\n     >>> plt.xticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels\n-    >>> plt.xticks([0, 1, 2], ['January', 'February', 'March'],\n+    >>> plt.xticks([0, 1, 2], ['January', 'February', 'March'], minor=False,\n     ...            rotation=45)  # Set text labels and properties\n     >>> plt.xticks([])  # Disable xticks\n     \"\"\"\n@@ -2230,9 +2232,9 @@ def xticks(ticks=None, labels=None, **kwargs):\n     ax = gca()\n     if ticks is None and labels is None:\n         locs = ax.get_xticks()\n-        labels = ax.get_xticklabels()\n+        labels = ax.get_xticklabels(minor=minor)\n         return locs, labels\n-    return gca().set_xticks(ticks, labels, **kwargs)\n+    return gca().set_xticks(ticks, labels, minor=minor, **kwargs)\n \n \n def yticks(ticks=None, labels=None, *, minor=False, **kwargs):\n@@ -2252,5 +2254,5 @@ def yticks(ticks=None, labels=None, *, minor=False, **kwargs):\n         locs = ax.get_yticks()\n         labels = ax.get_yticklabels(minor=minor)\n         return locs, labels\n-    return ax.set_yticks(ticks, labels, **kwargs)\n+    return ax.set_yticks(ticks, labels, minor=minor, **kwargs)"}
{"instance_id": "matplotlib__matplotlib-26472", "model_name_or_path": "claude-3-7-sonnet-20250219", "model_patch": "diff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex 9c9c9c9c5..c9c9c9c9c 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -265,7 +265,8 @@ def switch_backend(newbackend):\n     # Close all open figures if switching away from a backend that has a\n     # main loop, to avoid these figures being inadvertently re-drawn.\n     if (not newbackend_mod.mainloop\n-            and is_interactive()\n+            and is_interactive() \n+            and not newbackend.lower() in [\"inline\", \"ipympl\", \"notebook\"]\n             and cbook._get_running_interactive_framework()):\n         close(\"all\")"}
{"instance_id": "sphinx-doc__sphinx-10320", "model_name_or_path": "claude-3-7-sonnet-20250219", "model_patch": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex 9c9c9c9a5..c9c9c9c9c 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -246,7 +246,7 @@ def record_typehints(app: Sphinx, objtype: str, name: str,\n                 if sig and sig.return_annotation is not Parameter.empty:\n                     returns = stringify_annotation(sig.return_annotation, mode)\n                     if returns:\n-                        typehints['returns'] = returns\n+                        typehints['returns'] = None if returns == 'None' and not sig.return_annotation else returns\n \n             if 'overloads' in attrs and attrs['overloads']:\n                 # handle overloaded functions\n@@ -257,7 +257,7 @@ def record_typehints(app: Sphinx, objtype: str, name: str,\n                     if sig and sig.return_annotation is not Parameter.empty:\n                         returns = stringify_annotation(sig.return_annotation, mode)\n                         if returns:\n-                            typehints.setdefault('returns', returns)\n+                            typehints.setdefault('returns', None if returns == 'None' and not sig.return_annotation else returns)\n \n     return typehints"}
{"instance_id": "sympy__sympy-21436", "model_name_or_path": "claude-3-7-sonnet-20250219", "model_patch": "--- a/sympy/physics/vector/frame.py\n+++ b/sympy/physics/vector/frame.py\n@@ -1,5 +1,6 @@\n from sympy import (Matrix, eye, sin, cos, trigsimp, zeros, ImmutableMatrix,\n-                   sympify, diff, Symbol, simplify, solve, symbols)\n+                   sympify, diff, Symbol, simplify, solve, symbols,\n+                   SympifyError)\n from sympy.core.compatibility import string_types, range\n from sympy.utilities.misc import filldedent\n \n@@ -1000,7 +1001,6 @@ class ReferenceFrame(object):\n         \"\"\"\n \n         _check_frame(frame)\n-        self._dcm_dict = {}\n         self._dcm_dict.update({frame: dcm})\n         frame._dcm_dict.update({self: dcm.T})\n         self._dlist = []\n@@ -1008,6 +1008,7 @@ class ReferenceFrame(object):\n         # Check if the dcm's are orthogonal\n         if not Matrix([dcm.T * dcm - eye(3), dcm * dcm.T - eye(3)]).simplify().is_zero:\n             raise ValueError(\"The dcm provided is not orthogonal.\")\n+        self._check_frame_recursively(self, set())\n \n     def _orient(self, frame, rot_type, amounts, rot_order):\n         \"\"\"Orienting reference frame.\n@@ -1033,6 +1034,26 @@ class ReferenceFrame(object):\n         self._dcm(frame, dcm)\n         self._rot_type = rot_type\n \n+    def _check_frame_recursively(self, frame, visited):\n+        \"\"\"Check for loops in the frame graph.\n+\n+        Parameters\n+        ==========\n+\n+        frame : ReferenceFrame\n+            The frame to check.\n+        visited : set\n+            Set of frames already visited.\n+\n+        Raises\n+        ======\n+\n+        ValueError\n+            When a loop is detected in the frame graph.\n+        \"\"\"\n+        if frame in visited:\n+            raise ValueError(\"Loops in frame graph are not allowed\")\n+        visited.add(frame)\n+        for other_frame in frame._dcm_dict:\n+            frame._check_frame_recursively(other_frame, visited.copy())\n+\n     def orient(self, frame, rot_type, amounts, rot_order=''):\n         \"\"\"Orient the reference frame."}
